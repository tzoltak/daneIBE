% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/labelled_na_foreigndta.R
\name{labelled_na_foreigndta}
\alias{labelled_na_foreigndta}
\title{Konwersja ramki danych ze zmiennymi etykietowanymi do postaci dajacej
sie zapisac do pliku DTA}
\usage{
labelled_na_foreigndta(x, zachowajWartosciPustymiPoziomami = FALSE,
  naBrakiDanych = list(. = c("brak odpowiedzi", "odmowa odpowiedzi",
  "nie dotyczy", "ndt.")), pusteCiagiZnakow = ".")
}
\arguments{
\item{x}{ramka danych ze zmiennymi \emph{etykietowanymi}}

\item{zachowajWartosciPustymiPoziomami}{wartość logiczna: jeśli \code{FALSE},
zmienne \emph{etykietowane} po prostu zostaną skonwertowane na
\emph{czynnniki}, co może prowadzić do zmian wartości związanych
z poszczególnymi etykietami (p. sekcja \emph{Details}); jeśli \code{TRUE},
pierwotne wartości zostaną zachowane, jednak kosztem utworzenia dodatkowych
pustych poziomów \emph{czynników} dla wartości, które nie miały przypisanych
etykiet}

\item{naBrakiDanych}{lista wektorów tekstowych zawierających wartości etykiet,
które mają zostać przekodowane na różne typy braków danych Staty (choć ze
względu na ograniczenia funkcji \code{\link[foreign]{write.dta}} przy zapisie
mogą zostać uwzględnione tylko braki \emph{systemowe}, oznaczane jako ".");
nazwa elemntu listy podaje rodzaj braku danych (".", ".a", ... ".z")}

\item{pusteCiagiZnakow}{ciąg znaków, na który zostaną zamienione puste ciągi
znaków w zmiennych tekstowych (Stata nie jest w stanie zapisać pustego ciągu
znaków jako wartości zmiennej tekstowej)}
}
\value{
data.frame ze zmiennymi \emph{etykietowanymi} przekształconymi na
\emph{czynniki} i przypisanymi atrybutami analogicznymi do tych, jakie
mają przypisane ramki danych zwracane przez \code{\link[foreign]{read.dta}}
}
\description{
Funkcja konweruje ramkę danych zawierającą zmienne \emph{etykietowane}
(typowo wczytane funkcją \code{\link[haven]{read_spss}},
\code{\link[haven]{read_dta}}, lub \code{\link{zastosuj_codebook}})
do postaci odpowiadającej wynikowi działania funkcji
\code{\link[foreign]{read.dta}}. Tak przetworzoną ramkę danych można potem
w miarę bezproblemowo zapisać do formatu DTA korzystając z funkcji
\code{\link[foreign]{write.dta}}.
}
\details{
Zapis danych do formatu DTA poprzez funkcję \code{\link[foreign]{write.dta}}
został sklepany dosyć siermiężnie i jako etapu pośredniego wymaga konwersji
zmiennych \emph{etkietowanych} na \emph{czynniki}. Jeśli wartości, którym
przypisano etykiety nie są cięgiem kolejnych (poczynając od 1) liczb
naturalnych, wiąże się to albo z koniecznością pogodzenia się z tym, że
w zapisanym (tu: przygotowanym do zapisu) zbiorze nie będą zgadzać się z tymi,
jakie występowały w pierwotnym zbiorze, albo brzydko obchodzić ten problem
dodając puste etykiety wartości jako \emph{wypełniacz}. O tym, które
rozwiązanie funkcja (stara się) zastosować decyduje wartość argumentu
\code{zachowajWartosciPustymiPoziomami}.

Nawet jeśli argument \code{zachowajWartosciPustymiPoziomami=TRUE}, dodatkowe
puste poziomy zostaną utworzone tylko dla zmiennych, których wszystkie
wartości to dodatnie liczby całkowite.

Warto odnotować, że jeśli argument
\code{zachowajWartosciPustymiPoziomami=TRUE}, funkcja będzie czynić zło, tzn.
towrzyć \emph{czynniki} ze zduplikowanymi wartościami poziomów (co w zasadzie
jest niedozwolone).

Po zapisaniu zbioru funkcją \code{\link[foreign]{write.dta}} (należy pamiętać
o podaniu argumentu \code{convert.factors = "labels"}), warto jeszcze
otworzyć go w Stacie i wydać polecenie \code{compresss}, bo funkcja
\code{\link[foreign]{write.dta}} bardzo \emph{hojnie} obdziela zmienne
w zbiorze przestrzenią (nie próbuje sprawdzać, czy nie starczyłby
\emph{krótszy} format).
}
\examples{
\dontrun{
dane = zastosuj_codebook("plik z danymi.csv", "codebook.csv")
daneDoDta = labelled_na_foreigndta(dane)
write.dta(daneDoDta, "nazwa pliku.dta", version = 10, convert.factors = "labels")
}
}
